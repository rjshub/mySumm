<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue零散知识点</title>
</head>
<body>
<section>
    <div>
        <h4>一、watch和computed的比较</h4>
        <h5>1、computed</h5>
        <span>计算结果并返回，只有的那个被计算的只发生变化才会触发。</span>
        <span>（计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算）</span>
        <h5>2、watch</h5>
        <span>监听某一个值，当贝监听的值发生变化时，执行对应的操作。</span>
        <span>（与computed的区别是，watch更加适用于监听某一个值的变化并做对应的操作，比如请求后台接口等，而computed适用于计算已有的值并返回结果）</span>
        <br>
        <span>注意：不要在computed和watch中修改被依赖（或被监听）的值，这样可能导致进入无限循环。</span>
    </div>

    <div>
        <h4>二、Vue自定义指令</h4>
        <xmp>
            // 和自定义过滤器一样,我们这里定义的是全局指令
            Vue.directive('focus',{
                inserted(el) {
                el.focus()
                }
            })

            <div id='app'>
                <input type="text">
                <input type="text" v-focus placeholder="我有v-focus,所以,我获取了焦点">
            </div>
        </xmp>

        <span>1、使用 Vue.directive() 来新建一个全局指令,(指令使用在HTML元素属性上的)</span>
        <span>2、Vue.directive('focus') 第一个参数focus是指令名,指令名在声明的时候,不需要加 v-</span>
        <span>3、在使用指令的HTML元素上,<xmp><input type="text" v-focus placeholder="我有v-focus,所以,我获取了焦点"/></xmp> 我们需要加上 v-</span>
        <span>4、Vue.directive('focus',{}) 第二个参数是一个对象,对象内部有个 inserted() 的函数,函数有 el 这个参数</span>
    </div>
</section>
</body>
</html>
<style>
    section {
        padding: 0 100px;
        height: 100%;
    }
    span {
        display: block;
        line-height: 24px;
    }
</style>